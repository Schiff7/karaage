[//]: # ("tags": [ "React", "Generator", "Asynchronous" ], "category": "Uncategorized")

# 异步与状态管理

## 起因

最近在做的React单页应用（当前博客）需要异步从数据接口请求相关的数据，由于不希望把相关逻辑分散到各个组件里，产生了想要对组件的状态（主要为异步状态）进行集中管理的想法。项目在慢慢的用Typescript来重写，Redux原本对于这么小的应用（原本只分了两个文件）来说已经太重了，更不用说配上类型。我希望有一个更**简单**的，或许并不是well-design的，这是我想自己实现的理由。

## 想法

### 入口

如果把状态管理的组件当作一个黑盒，当注册一个新的状态时，需要向其提供哪些信息？

以将提供的信息最小化进行考量的话，我认为有以下三点：

- 唯一键
- 状态的当前值（或初始值）
- 状态的更新函数

如果状态是同步更新的，状态的更新函数是一个纯函数，它可能基于旧的状态（或者忽略），生成新的状态。

然而，如果状态的更新需要执行异步操作，意味无法立即返回执行结果，此时不得不将修改状态的接口（副作用）传递到更新函数内部，作为异步操作的回调。

同时，相较于同步更新时状态由旧到新的直接转变，异步更新时旧的状态与新的状态之间多出一种中间态，此时更新函数已经被执行，旧的状态还没有被更新。这种状态是应该被应用所知晓的。

### `Generator`作为异步更新函数

想到`Generator`更多是因为想要驱动自己尝试去使用一些知道但不是特别了解的东西来解决问题，也刚好满足了此刻的需求。

首先是异步状态更新的第一个问题：回调函数与副作用。

函数之所以被用于回调，是希望它可以在指定的上下文（context）中执行。